!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):t.VuexClass=e()}(this,function(){"use strict";const t="_[vuex-class]_init",e=t=>"function"==typeof t,s=t=>{const e=[];let s=t;for(;s!==n.prototype;)s=Object.getPrototypeOf(s),e.push(s);return e},o=t=>{const e={};let s=t.length;for(;s--;){const o=t[s];Object.assign(e,Object.getOwnPropertyDescriptors(o))}return e},i=t=>{throw new Error(`[vuex-class] ${t}`)};class n{constructor(){const n=o(s(this));this.state={},this.getters={},this.mutations={},this.actions={};let c=null;Object.defineProperty(this,"context",{get:()=>(c||i("Please call the 'new Vuex.store({ plusins: [ VuexClass.init() ] })' method"),c),set(t){c=t}}),Object.keys(n).forEach(t=>{if("constructor"===t)return;const s=n[t],o={};e(s.get)&&(o.get=(()=>this.context.getters[t]),this.getters[t]=(()=>s.get.call(this))),e(s.set)&&(o.set=(e=>this.context.commit(t,e)),this.mutations[t]=((t,e)=>s.set.call(this,e)),e(s.get)||(o.get=(()=>e=>this.context.commit(t,e)))),e(s.value)&&(o.value=(e=>this.context.dispatch(t,e)),this.actions[t]=((t,e)=>s.value.call(this,e))),Object.defineProperty(this,t,o)}),Object.assign(this.actions,{[t]:{root:!0,handler:t=>{this.context=t,Object.defineProperty(this,"state",{get:()=>this.context.state,set(){i("You should not update the module state directly")}})}}})}}return n.init=function(){return e=>{e.dispatch(t)}},n});
